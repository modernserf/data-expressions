<!doctype html>
<html >
<head >
<title >
test.js
</title>
<style >

  body {
    margin: 0 auto;
    max-width: 800px;
  }
  .test {
    border: 1px solid #ccc;
    padding: 1em;
  }
  code {
    display: block;
    white-space: pre;
    line-height: 0.7;
  }
  .comment code {
    display: inline-block;
    background-color: #eee;
  }
  section {
    margin: 1em 0;
  }

</style>
</head>
<body >
<aside class="comment">
<h1 id="test-framework">Test framework</h1>
<p> This library has its code, documentation, and tests intertwingled; the tests act as examples for the code. This is made possible with Rollup&#39;s &quot;tree-shaking&quot; -- the tests aren&#39;t included in the bundled output.</p>

</aside>
<details >
<section class="details-body">
import * as patterns from './patterns.js'
<code >
import * as parser from './parser.js'
</code>
<code >
import * as index from './index.js'
</code>
<code >
const tape = require('tape')
</code>
</section>
</details>
<aside class="comment">
<p> Use Jasmine-style <code>expect(value).toEqual(expected)</code> test assertions.</p>

</aside>
<details >
<section class="details-body">
function expecter (t) {
<code >
  const f = (value) => ({
</code>
<code >
    toEqual: (expected) => t.deepEquals(value, expected),
</code>
<code >
    toThrow: () => t.throws(value)
</code>
<code >
  })
</code>
<code >
  f.comment = (comment) => t.comment(comment)
</code>
<code >
  return f
</code>
<code >
}
</code>
</section>
</details>
<aside class="comment">
<p> Use the exported function&#39;s name to determine if it&#39;s a test, and if it should be skipped/isolated.</p>

</aside>
<details >
<section class="details-body">
function tester (tape, key, cb) {
<code >
  const test = /^only_test_/.test(key) ? tape.only
</code>
<code >
    : /^skip_test_/.test(key) ? tape.skip
</code>
<code >
      : /^test_/.test(key) ? tape
</code>
<code >
        : null
</code>
<code >
  if (!test) { return }
</code>
<aside class="comment">
<p> Extract a properly-formatted name from the test function name.</p>

</aside>
<code >
  const message = key.replace(/^(skip_|only_)?test_/, '').replace(/_/g, ' ')
</code>
<code >
  return test(message, cb, { objectPrintDepth: 10 })
</code>
<code >
}
</code>
</section>
</details>
<aside class="comment">
<p> If any of the exported values are test functions, run them with <code>tape</code>.</p>

</aside>
<details >
<section class="details-body">
for (const dep of [patterns, parser, index]) {
<code >
  for (const key in dep) {
</code>
<code >
    tester(tape, key, (t) => {
</code>
<aside class="comment">
<p> Call the test with <code>expect</code> and <code>dx</code> as arguments.</p>

</aside>
<code >
      const out = dep[key](expecter(t), parser.dx)
</code>
<aside class="comment">
<p> Return values are ignored, but async functions always return a promise, so assume a return value implies an async test.</p>

</aside>
<code >
      if (out) {
</code>
<code >
        Promise.resolve(out).then(() => t.end())
</code>
<code >
      } else {
</code>
<code >
        t.end()
</code>
<code >
      }
</code>
<code >
    })
</code>
<code >
  }
</code>
<code >
}
</code>
</section>
</details>
</body>
</html>
